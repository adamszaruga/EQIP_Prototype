/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin editor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"
#include "internalFilters.h"


/** A window to show all the available plugins */
class EqipAudioProcessorEditor::PluginListWindow : public DocumentWindow
{
public:
	PluginListWindow(EqipAudioProcessorEditor& owner_, AudioPluginFormatManager& formatManager)
		: DocumentWindow("Available Plugins", Colours::white,
		DocumentWindow::minimiseButton | DocumentWindow::closeButton),
		owner(owner_)
	{

		const File deadMansPedalFile(owner.appProperties.getUserSettings()->getFile().getSiblingFile("RecentlyCrashedPluginsList"));

		setContentOwned(new PluginListComponent(formatManager,
			owner.knownPluginList,
			deadMansPedalFile,
			owner.appProperties.getUserSettings()), true);

		setResizable(true, false);
		setResizeLimits(300, 400, 800, 1500);
		setTopLeftPosition(60, 60);

		restoreWindowStateFromString(owner.appProperties.getUserSettings()->getValue("listWindowPos"));
		setVisible(true);
	}

	~PluginListWindow()
	{
		owner.appProperties.getUserSettings()->setValue("listWindowPos", getWindowStateAsString());

		clearContentComponent();
	}

	void closeButtonPressed()
	{
		owner.pluginListWindow = nullptr;
	}

private:
	EqipAudioProcessorEditor& owner;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(PluginListWindow)
};

//==============================================================================
EqipAudioProcessorEditor::EqipAudioProcessorEditor (EqipAudioProcessor& p)
    : AudioProcessorEditor (&p), 
      processor (p), 
	  pluginList("PluginList"),
	  button1("Button"),
	  menuBar(this),
	  graph(formatManager)
	  
{
	// Set up Format Manager
	formatManager.addDefaultFormats();
	formatManager.addFormat(new InternalPluginFormat());
	graph.addInitialFilters();
    
    // Set up Properties files
	options.applicationName = "EQIP";
	options.filenameSuffix = "settings";
	options.osxLibrarySubFolder = "Preferences";
	appProperties.setStorageParameters(options);
    
	ScopedPointer<XmlElement> savedAudioState (appProperties.getUserSettings()->getXmlValue("audioDeviceState"));
	
	// Set up Audio Device connection
	deviceManager.initialise(256, 256, savedAudioState, true);
	graphPlayer.setProcessor(&graph.getGraph());
	deviceManager.addAudioCallback(&graphPlayer);

	InternalPluginFormat internalFormat;
	internalFormat.getAllTypes(internalTypes);

	// Recover list of scanned plugins
	ScopedPointer<XmlElement> savedPluginList (appProperties.getUserSettings()->getXmlValue("pluginList"));

	if (savedPluginList != nullptr)
		knownPluginList.recreateFromXml(*savedPluginList);

	pluginSortMethod = (KnownPluginList::SortMethod) appProperties.getUserSettings()->getIntValue("pluginSortMethood", KnownPluginList::sortByManufacturer);

	knownPluginList.addChangeListener(this);

	

    //add GUI elements
	addAndMakeVisible(menuBar);
	pluginList.setModel(new PluginListModel(&button1, &knownPluginList));
	TableHeaderComponent *header = new TableHeaderComponent();
	header->addColumn("row", 1, 600, 600, 600, TableHeaderComponent::ColumnPropertyFlags::notResizableOrSortable);
	pluginList.setHeader(header);
	addAndMakeVisible(pluginList);
	pluginList.updateContent();

	addAndMakeVisible(button1);
	button1.addListener(this);
	

    // Make sure that before the constructor has finished, you've set the
    // editor's size to whatever you need it to be.
    
	setSize(800, 600);
}

EqipAudioProcessorEditor::~EqipAudioProcessorEditor()
{
	pluginListWindow = nullptr;

	knownPluginList.removeChangeListener(this);
	deviceManager.removeAudioCallback(&graphPlayer);
	graphPlayer.setProcessor(nullptr);
	graph.clear();

}

//==============================================================================
void EqipAudioProcessorEditor::paint (Graphics& g)
{
    g.fillAll (Colour::Colour( 0xff18191A));


    g.setColour (Colours::black);
    g.setFont (15.0f);
	g.drawFittedText("Hello World!", getLocalBounds(), Justification::centred, 1);
}

void EqipAudioProcessorEditor::resized()
{
	menuBar.setBounds(0,0,800,20);
	pluginList.setBounds(0, 20, 800, 300);
	button1.setBounds(0, 330, 100, 50);
}

//==============================================================================
void EqipAudioProcessorEditor::changeListenerCallback(ChangeBroadcaster*)
{
	// Call a function to update the pluginlist gui element
	//******** FUNCTION HERE ************//

	// Save the plugin list everytime it gets changed
	ScopedPointer<XmlElement> savedPluginList (knownPluginList.createXml());

	if (savedPluginList != nullptr)
	{
		appProperties.getUserSettings()->setValue("pluginList", savedPluginList);
		appProperties.saveIfNeeded();
	}

}

void EqipAudioProcessorEditor::showAudioSettings()
{
	AudioDeviceSelectorComponent audioSettingsComp(deviceManager, 0, 256, 0, 256, true, true, true, false);

	audioSettingsComp.setSize(500, 450);

	DialogWindow::LaunchOptions o;
	o.content.setNonOwned(&audioSettingsComp);
	o.dialogTitle = "Audio Settings";
	o.componentToCentreAround = this;
	o.dialogBackgroundColour = Colours::azure;
	o.escapeKeyTriggersCloseButton = true;
	o.useNativeTitleBar = false;
	o.resizable = false;

	o.runModal();

	ScopedPointer<XmlElement> audioState(deviceManager.createStateXml());

	appProperties.getUserSettings()->setValue("audioDeviceState", audioState);
	appProperties.getUserSettings()->saveIfNeeded();
}

//==============================================================================
StringArray EqipAudioProcessorEditor::getMenuBarNames()
{
	const char* const names[] = { "File", nullptr };
	return StringArray(names);
}

PopupMenu EqipAudioProcessorEditor::getMenuForIndex(int topLevelMenuIndex, const String& /*menuName*/)
{
	PopupMenu menu;

	if (topLevelMenuIndex == 0)
	{
		// "File" menu
		menu.addItem(100, "Edit the List of available plugins", true, false);

		PopupMenu sortTypeMenu;
		sortTypeMenu.addItem(200, "List plugins in default order",		true, pluginSortMethod == KnownPluginList::defaultOrder);
		sortTypeMenu.addItem(201, "List plugins in alphabetical order", true, pluginSortMethod == KnownPluginList::sortAlphabetically);
		sortTypeMenu.addItem(202, "List plugins by category",			true, pluginSortMethod == KnownPluginList::sortByCategory);
		sortTypeMenu.addItem(203, "List plugins by manufacturer",		true, pluginSortMethod == KnownPluginList::sortByManufacturer);
		sortTypeMenu.addItem(204, "List plugins based on the directory structure", true, pluginSortMethod == KnownPluginList::sortByFileSystemLocation);
		menu.addSubMenu("Sort by", sortTypeMenu);

		menu.addSeparator();
		menu.addItem(300, "Audio device settings", true, false);

	}
	return menu;
}

void EqipAudioProcessorEditor::menuItemSelected(int menuItemID, int topLevelMenuIndex)
{
	if (menuItemID == 200)	pluginSortMethod = KnownPluginList::defaultOrder;
	else if (menuItemID == 201)	pluginSortMethod = KnownPluginList::sortAlphabetically;
	else if (menuItemID == 202)	pluginSortMethod = KnownPluginList::sortByCategory;
	else if (menuItemID == 203)	pluginSortMethod = KnownPluginList::sortByManufacturer;
	else if (menuItemID == 204)	pluginSortMethod = KnownPluginList::sortByFileSystemLocation;
	else if (menuItemID == 100) {
		if (pluginListWindow == nullptr)
			pluginListWindow = new PluginListWindow(*this, formatManager);
		pluginListWindow->toFront(true);
	}
	else if (menuItemID == 300) showAudioSettings();
}

void EqipAudioProcessorEditor::createPlugin(const PluginDescription* desc, int x, int y)
{
	

}

void EqipAudioProcessorEditor::buttonClicked(Button* button)
{
	int pluginIndex = (button->getButtonText()).getIntValue();
	graph.trialFilter(knownPluginList.getType(pluginIndex), 0.5f, 0.5f);

	PluginWindow* const w = PluginWindow::getWindowFor(graph.getNodeForId(graph.lastUID),PluginWindow::WindowFormatType::Normal);
	w->toFront(true) ;
}
//*****************************
// Plugin Window stuff
class PluginWindow;
static Array <PluginWindow*> activePluginWindows;

PluginWindow::PluginWindow(Component* const pluginEditor,
	AudioProcessorGraph::Node* const o,
	WindowFormatType t)
	: DocumentWindow(pluginEditor->getName(), Colours::lightblue,
	DocumentWindow::minimiseButton | DocumentWindow::closeButton),
	owner(o),
	type(t)
{
	setSize(400, 300);

	setContentOwned(pluginEditor, true);

	setTopLeftPosition(owner->properties.getWithDefault("uiLastX", Random::getSystemRandom().nextInt(500)),
		owner->properties.getWithDefault("uiLastY", Random::getSystemRandom().nextInt(500)));
	setVisible(true);

	activePluginWindows.add(this);
}

void PluginWindow::closeCurrentlyOpenWindowsFor(const uint32 nodeId)
{
	for (int i = activePluginWindows.size(); --i >= 0;)
		if (activePluginWindows.getUnchecked(i)->owner->nodeId == nodeId)
			delete activePluginWindows.getUnchecked(i);
}

void PluginWindow::closeAllCurrentlyOpenWindows()
{
	if (activePluginWindows.size() > 0)
	{
		for (int i = activePluginWindows.size(); --i >= 0;)
			delete activePluginWindows.getUnchecked(i);

		Component dummyModalComp;
		dummyModalComp.enterModalState();
		MessageManager::getInstance()->runDispatchLoopUntil(50);
	}
}


class ProcessorProgramPropertyComp : public PropertyComponent,
	private AudioProcessorListener
{
public:
	ProcessorProgramPropertyComp(const String& name, AudioProcessor& p, int index_)
		: PropertyComponent(name),
		owner(p),
		index(index_)
	{
		owner.addListener(this);
	}

	~ProcessorProgramPropertyComp()
	{
		owner.removeListener(this);
	}

	void refresh() { }
	void audioProcessorChanged(AudioProcessor*) { }
	void audioProcessorParameterChanged(AudioProcessor*, int, float) { }

private:
	AudioProcessor& owner;
	const int index;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(ProcessorProgramPropertyComp)
};

class ProgramAudioProcessorEditor : public AudioProcessorEditor
{
public:
	ProgramAudioProcessorEditor(AudioProcessor* const p)
		: AudioProcessorEditor(p)
	{
		jassert(p != nullptr);
		setOpaque(true);

		addAndMakeVisible(panel);

		Array<PropertyComponent*> programs;

		const int numPrograms = p->getNumPrograms();
		int totalHeight = 0;

		for (int i = 0; i < numPrograms; ++i)
		{
			String name(p->getProgramName(i).trim());

			if (name.isEmpty())
				name = "Unnamed";

			ProcessorProgramPropertyComp* const pc = new ProcessorProgramPropertyComp(name, *p, i);
			programs.add(pc);
			totalHeight += pc->getPreferredHeight();
		}

		panel.addProperties(programs);

		setSize(400, jlimit(25, 400, totalHeight));
	}

	void paint(Graphics& g)
	{
		g.fillAll(Colours::grey);
	}

	void resized()
	{
		panel.setBounds(getLocalBounds());
	}

private:
	PropertyPanel panel;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(ProgramAudioProcessorEditor)
};


PluginWindow* PluginWindow::getWindowFor(AudioProcessorGraph::Node* const node,
	WindowFormatType type)
{
	jassert(node != nullptr);

	for (int i = activePluginWindows.size(); --i >= 0;)
		if (activePluginWindows.getUnchecked(i)->owner == node
			&& activePluginWindows.getUnchecked(i)->type == type)
			return activePluginWindows.getUnchecked(i);

	AudioProcessor* processor = node->getProcessor();
	AudioProcessorEditor* ui = nullptr;

	if (type == Normal)
	{
		ui = processor->createEditorIfNeeded();

		if (ui == nullptr)
			type = Generic;
	}

	if (ui == nullptr)
	{
		if (type == Generic || type == Parameters)
			ui = new GenericAudioProcessorEditor(processor);
		else if (type == Programs)
			ui = new ProgramAudioProcessorEditor(processor);
	}

	if (ui != nullptr)
	{
		if (AudioPluginInstance* const plugin = dynamic_cast<AudioPluginInstance*> (processor))
			ui->setName(plugin->getName());

		return new PluginWindow(ui, node, type);
	}

	return nullptr;
}

PluginWindow::~PluginWindow()
{
	activePluginWindows.removeFirstMatchingValue(this);
	clearContentComponent();
}

void PluginWindow::moved()
{
	owner->properties.set("uiLastX", getX());
	owner->properties.set("uiLastY", getY());
}

void PluginWindow::closeButtonPressed()
{
	delete this;
}

