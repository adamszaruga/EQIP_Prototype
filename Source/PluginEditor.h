/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin editor.

  ==============================================================================
*/

#ifndef PLUGINEDITOR_H_INCLUDED
#define PLUGINEDITOR_H_INCLUDED

#include "../JuceLibraryCode/JuceHeader.h"
#include "PluginProcessor.h"
#include "internalFilters.h"
#include "FilterGraph.h"


//==============================================================================
/**
*/
class EqipAudioProcessorEditor  : public AudioProcessorEditor,
								  public ChangeListener,
								  public MenuBarModel,
								  public ButtonListener
{
public:
    EqipAudioProcessorEditor (EqipAudioProcessor&);
    ~EqipAudioProcessorEditor();

    //==============================================================================
    void paint (Graphics&) override;
    void resized() override;
    

	// Change Listener Requirements
	void changeListenerCallback(ChangeBroadcaster*);

	// Plugin Host Requirements
	// I moved these here from the private section. The OO has been ruined!
	AudioDeviceManager deviceManager;
	AudioPluginFormatManager formatManager;

	OwnedArray <PluginDescription> internalTypes;
	KnownPluginList knownPluginList;
	KnownPluginList::SortMethod pluginSortMethod;
	ApplicationProperties appProperties;
	PropertiesFile::Options options;
	FilterGraph graph;
	AudioProcessorPlayer graphPlayer;
	

	StringArray getMenuBarNames();
	PopupMenu getMenuForIndex(int topLevelMenuIndex, const String& menuName);
	void menuItemSelected(int menuItemID, int topLevelMenuIndex);

	
	void createPlugin(const PluginDescription* desc, int x, int y);

	void showAudioSettings();

	class PluginListWindow;
	ScopedPointer <PluginListWindow> pluginListWindow;

	void buttonClicked(Button* button);

private:
    // This reference is provided as a quick way for your editor to
    // access the processor object that created it.
    EqipAudioProcessor& processor;
	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(EqipAudioProcessorEditor)

	

    // GUI elements
    TableListBox pluginList;
	TextButton button1; 
	MenuBarComponent menuBar;

	

};

//==============================================================================
/** A desktop window containing a plugin's UI. */
class PluginWindow : public DocumentWindow
{
public:
	enum WindowFormatType
	{
		Normal = 0,
		Generic,
		Programs,
		Parameters
	};

	PluginWindow(Component* pluginEditor, AudioProcessorGraph::Node*, WindowFormatType);
	~PluginWindow();

	static PluginWindow* getWindowFor(AudioProcessorGraph::Node*, WindowFormatType);

	static void closeCurrentlyOpenWindowsFor(const uint32 nodeId);
	static void closeAllCurrentlyOpenWindows();

	void moved() override;
	void closeButtonPressed() override;

private:
	AudioProcessorGraph::Node* owner;
	WindowFormatType type;

	float getDesktopScaleFactor() const override     { return 1.0f; }

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(PluginWindow)
};
//==============================================================================
/** A model for the plugin list */

class PluginListModel : public TableListBoxModel
{
public:

	PluginListModel(TextButton* button, KnownPluginList* kpl)
	{
		pluginButton = button;
		knownPluginList = kpl;
	}
	~PluginListModel()
	{

	}
	
	virtual int getNumRows()
	{
		return rows;
	}

	virtual void paintRowBackground(Graphics& g,
		int rowNumber,
		int width, int height,
		bool rowIsSelected)
	{
		if (rowNumber >= rows)
		{
			g.fillAll(Colours::red);
		}
	}

	virtual void paintCell(Graphics& g,
		int rowNumber,
		int columnId,
		int width, int height,
		bool rowIsSelected)
	{
		if (rowNumber >= rows)
		{
			// Argh! We don't have this many rows!
			jassertfalse;
		}
		else if (rowIsSelected)
		{
			g.fillAll(LookAndFeel::getDefaultLookAndFeel().findColour(TextEditor::highlightColourId));
		}
		g.drawText( (knownPluginList->getType(rowNumber))->name,
			0, 0, width, height,
			Justification::centredLeft, false);
	}

	virtual void cellClicked(int rowNumber,
		int columnId,
		const MouseEvent &)
	{
		pluginButton->setButtonText(String(rowNumber));
	}

private:
	const static int rows = 2;
	TextButton * pluginButton;
	KnownPluginList * knownPluginList;
};

/** A window to show all the available plugins */
class PluginListWindow : public DocumentWindow
{
public:
	PluginListWindow(EqipAudioProcessorEditor& owner_, AudioPluginFormatManager& formatManager)
		: DocumentWindow("Available Plugins", Colours::white,
		DocumentWindow::minimiseButton | DocumentWindow::closeButton),
		owner(owner_)
	{

		const File deadMansPedalFile(owner.appProperties.getUserSettings()->getFile().getSiblingFile("RecentlyCrashedPluginsList"));

		setContentOwned(new PluginListComponent(formatManager,
			owner.knownPluginList,
			deadMansPedalFile,
			owner.appProperties.getUserSettings()), true);

		setResizable(true, false);
		setResizeLimits(300, 400, 800, 1500);
		setTopLeftPosition(60, 60);

		restoreWindowStateFromString(owner.appProperties.getUserSettings()->getValue("listWindowPos"));
		setVisible(true);
	}

	~PluginListWindow()
	{
		owner.appProperties.getUserSettings()->setValue("listWindowPos", getWindowStateAsString());

		clearContentComponent();
	}

	void closeButtonPressed()
	{
		owner.pluginListWindow = nullptr;
	}

private:
	EqipAudioProcessorEditor& owner;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(PluginListWindow)
};


#endif  // PLUGINEDITOR_H_INCLUDED
